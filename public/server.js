let availableUsers=[];const rooms=[];module.exports={io:e=>{e.on("nU",(({type:o="online",friendRoom:n="",createRoom:r=!1,player:i={}},s)=>{i.id=e.id;const a=availableUsers.filter((e=>e.type===o&&e.player.token!==i.token));if(0!==a.length&&!r||"friend"===o&&!r){let r=-1;if("online"===o&&(r=randomNumber(0,a.length-1)),"friend"===o&&(r=a.findIndex((e=>e.room===n)),r<0))return s("Invalid room");if(r<0)return s("Invalid type");const l={player:i,partner:a[r].player},t=setOrder(["player","partner"].map((e=>[l[e].name,l[e].token,0,l[e].id]))),d=a[r].room,m={BOARD:newBoard(),users:t,room:d,typeGame:3};e.join(d),rooms.push({room:d,users:[l.player.id,l.partner.id]});const p=availableUsers.findIndex((e=>e.room===d));availableUsers.splice(p,1),io.sockets.in(d).emit("sG",m)}else{const r=String("online"===o?guid():n);availableUsers.push({room:r,type:o,player:i}),e.join(r)}s()})),e.on("action",(e=>{if("end"!==e.type)io.sockets.in(e.room).emit("action",e);else{const o=rooms.findIndex((({room:o})=>e.room===o));o>=0&&rooms.splice(o,1)}})),e.on("disconnect",(()=>{const o=rooms.findIndex((({users:o})=>[o[0],o[1]].includes(e.id)));if(o>=0)io.sockets.in(rooms[o].room).emit("action",{type:"leave"}),rooms.splice(o,1);else{const o=availableUsers.findIndex((({player:o})=>o.id===e.id));o>=0&&availableUsers.splice(o,1)}}))}};